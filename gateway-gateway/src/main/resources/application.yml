spring:
  application:
    name: cloud-gateway
  profiles:
    active: dev
  cloud:
    gateway:
      discovery:
        locator:
          # 请求服务名称可以用小写
          lower-case-service-id: true

      #测试环境暂不需要设置
      globalcors:
        cors-configurations:
          '[/**]': # 匹配所有请求
            allowedOrigins: #设置支持的域名
              - "http://service1.bb.co"
              - "http://service2.bb.co"
            allowedHeaders: "*" # 支持的方法
            allowCredentials: true # 设置允许携带cookie，为true时allowedOrigins不允许为*会报错
            allowedMethods: # 支持的方法
              - GET
              - POST
              - PUT
              - OPTIONS
              - DELETE
              - PATCH
      default-filters:
        #解决双重跨域
#        - DedupeResponseHeader=Vary Access-Control-Allow-Origin Access-Control-Allow-Credentials, RETAIN_FIRST
        - name: Hystrix
          args:
            name: fallbackcmd #HystrixCmommand的名字
            fallbackUri: forward:/fallback #fallback名字的URI

#      default-filters:
#        - name: RequestRateLimiter
#          args:
#            redis-rate-limiter.replenishRate: 2
#            #              令牌桶的容量 桶内能装200个令牌，相当于峰值，要注意的是：第一秒从桶内能去200个，但是第二秒只能取到100个了，因为入桶速度是每秒100
#            redis-rate-limit.burstCapacity: 20
#            # 每个请求需要的令牌数
#            redis-rate-limiter.requestedTokens: 1
#            key-resolver: "#{@apiKeyResolver}"
      routes:
#       ##############################################################################################################
        # 限流测试
        - id: customer1-route
          uri: lb://cloud-user
          predicates:
            - Path=/limiter/**
          filters:
            - RewritePath=/limiter, /user
            # 转发前去掉一层路径
            - StripPrefix=1
            - name: RequestRateLimiter
              args:
              #              允许用户每秒处理多少请求  # 令牌入桶的速度为每秒2个，相当于QPS
                redis-rate-limiter:
                  replenish-rate: 5
              #              令牌桶的容量 桶内能装200个令牌，相当于峰值，要注意的是：第一秒从桶内能去200个，但是第二秒只能取到100个了，因为入桶速度是每秒100
                  burst-capacity: 10
              # 每个请求需要的令牌数
                  requested-tokens: 1
                  key-resolver: "#{@apiKeyResolver}"
        #              rate-limiter: "#{@defaultRateLimiter}"
        #              key-resolver: "#{@hostAddKeyResolver}"
        #              default-rate-limit.permitsPerSecond: 1
#       ##############################################################################################################
#        - id: cloud-user
#          uri: lb://cloud-user
#          predicates:
#            - Path=/user/**
#        - id: cloud-order
#          uri: lb://cloud-order
#          predicates:
#            - Query=foo, ba
#        - id: redirect-baidu
#          uri: http://www.baidu.com
#          predicates:
#            - Method=GET
        # 自定义路由断言工厂 那个args的地方是真的坑， 位置不对不对齐就不行 但是为什么不生效
        - id: customer-route
          uri: lb://cloud-user
          predicates:
            - Path=/user/**
            - AgeAuth=18,60
#            - name: CheckAuth
#              args:
#                name: killer1
        - id: order-route
          uri: lb://cloud-order
          order: 1
          predicates:
            - Path=/order/**
          filters:
            - StripPrefix=1 # 转发前去掉一层路径
            - Log=true,true
#       熔断测试
        - id: user-service
          uri: lb://cloud-user
          predicates:
            - Path=/hystrix/**
          filters:
#            - StripPrefix=1 # 转发前去掉一层路径
            name: Hystrix
            args:
              name: fallbackcmd
              fallbackUrl: forward:/fallback
#      redis-rate-limiter:
#        config:
#            replenishRate: 1
#            #              令牌桶的容量 桶内能装200个令牌，相当于峰值，要注意的是：第一秒从桶内能去200个，但是第二秒只能取到100个了，因为入桶速度是每秒100
#            burstCapacity: 5
#            # 每个请求需要的令牌数
#            requestedTokens: 1
#            key-resolver: "#{@apiKeyResolver}"


server:
  port: 9999

#熔断参数配置
hystrix:
  threshold: 20
  command:
    default:
      execution:
        timeout:
          enable: true
        isolation:
          #保证feign调用header不丢失
          #          strategy: SEMAPHORE
          thread:
            timeoutInMilliseconds: 5000
    fallbackcmd:
      execution:
        timeout:
          enable: true
        isolation:
          #          #保证feign调用header不丢失
          #          strategy: SEMAPHORE
          thread:
            timeoutInMilliseconds: 5000

